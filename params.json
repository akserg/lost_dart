{"name":"Lost Dart","tagline":"Lost Dart is Inversion of Control Container implementation for Dart.","body":"##Lost Dart\r\n\r\nLost Dart is lightweight dependency injection framework for Dart client and server applications.\r\n\r\n[![](https://drone.io/akserg/lost_dart/status.png)](https://drone.io/akserg/lost_dart/latest)\r\n\r\nIt helps you split your application into a collection of loosely-coupled pieces and then glue them back together in a flexible manner. Its aim is to make wide range of Dart applications easier to:\r\n* Manage source code;\r\n* Encouraging code modularisation;\r\n* Separations of concerns;\r\n* Good unit testing practices.\r\n\r\n###Set up\r\nLost Dart is available under the lost_dart pub package. Simply add a dependency to your pubspec.yaml file:\r\n\r\n<pre class=\"syntax brush-javascript\">\r\n...\r\ndependencies:\r\n  lost_dart: any\r\n</pre> \r\n\r\nThen run pub install and youâ€™ll have everything you need to get started.\r\n\r\n##The core concepts of Lost Dart by examples\r\n\r\n###Instantiation\r\n\r\nA simple example of using the Lost Dart is that to construct an instance of an object. \r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n// Class Baz\r\nclass Baz{\r\n  String name;\r\n  \r\n  Baz([this.name = \"\"]);\r\n}\r\n\r\nvoid main() {\r\n  // Create container\r\n  Container container = new Container();\r\n  \r\n  // Bind Baz\r\n  container.bind(Baz);\r\n  container.bindAs(\"baz2\");\r\n  \r\n  // Resolve baz by type\r\n  Baz baz = container.get(Baz);\r\n  Baz baz2 = container.getAs(\"baz\");\r\n\r\n  assert(baz.name == \"\");\r\n  assert(baz2.name == \"\");\r\n}\r\n</pre>\r\n\r\n###Constructor injection: Constant arguments\r\n\r\nConstant values are set an constructor argument:\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n// Class Baz\r\nclass Baz{\r\n  String name;\r\n  int number = 22;\r\n  \r\n  Baz([this.name = \"\"]);\r\n}\r\n\r\nvoid main() {\r\n  // Create IoC container\r\n  Container container = new Container();\r\n  // Bind Baz\r\n  container.bind(Baz).addConstructorConstArg(\"Test\");\r\n  container.bindAs(\"baz2\").to(Baz).addConstructorConstArg(\"Test2\");\r\n\r\n  // Resolve baz\r\n  Baz baz = container.get(Baz);\r\n  Baz baz2 = container.getAs(\"baz2\");\r\n\r\n  // Test result\r\n  assert(baz.name == \"Test\");\r\n  assert(baz2.name == \"Test2\");\r\n}\r\n</pre>\r\n\r\n###Constructor injection: Dependencies\r\n\r\nA tree of dependencies are instantiated and injected using the constructor argument:\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n// application code\r\nclass Baz{\r\n  String name;\r\n  int number = 22;\r\n\r\n  Baz([this.name = \"99\"]);\r\n}\r\n\r\nclass Bar{\r\n  Baz baz;\r\n  Bar(this.baz);\r\n}\r\n\r\n\r\nvoid main() {\r\n  // Create IoC container\r\n  Container container = new Container();\r\n\r\n  container.bind(Baz);\r\n  container.bind(Bar).addConstructorTypeArg(Baz);\r\n  container.bindAs(\"bar2\").to(Bar).addConstructorTypeArg(Baz);\r\n\r\n  // Resolve bar\r\n  Bar bar = container.get(Bar);\r\n  Bar bar2 = container.getAs(\"bar2\");\r\n\r\n  // Test result of bar\r\n  assert(bar != null);\r\n  assert(bar.baz.name == \"99\");\r\n  assert(bar2 != null);\r\n  assert(bar2.baz.name == \"99\");\r\n  assert(bar.baz == bar.baz);\r\n}\r\n</pre>\r\n\r\n###Property injection: Constant values\r\n\r\nConstant values are set in the property:\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n// application code\r\nclass Baz{\r\n  String name;\r\n  int number = 22;\r\n\r\n  Baz([this.name = \"99\"]);\r\n}\r\n\r\nvoid main() {\r\n  // Create IoC container\r\n  Container container = new Container();\r\n\r\n  // Bind Baz\r\n  container.bind(Baz).setConstProperty(\"number\", 33);\r\n  container.bindAs(\"baz2\").to(Baz).setConstProperty(\"number\", 44);\r\n\r\n  // Resolve baz\r\n  Baz baz = container.get(Baz);\r\n  Baz baz2 = container.getAs(\"baz2\");\r\n  \r\n  // Test result\r\n  assert(baz.number == 33);\r\n  assert(baz2.number == 44);\r\n}\r\n</pre>\r\n\r\n###Property injection: Dependencies\r\n\r\nA tree of dependencies are instantiated and injected using the property:\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n// application code\r\nclass Baz{\r\n  String name;\r\n\r\n  Baz([this.name = \"99\"]);\r\n}\r\n\r\nclass Bar{\r\n  Baz baz;\r\n\r\n  Bar();\r\n}\r\n\r\nvoid main() {\r\n\r\n  // Create IoC container\r\n  Container container = new Container();\r\n\r\n  // Bind Bar\r\n  container.bind(Bar).setTypeProperty(\"baz\", Bar);\r\n  container.bindAs(\"bar2\").to(Bar).setTypeProperty(\"baz\", Bar);\r\n\r\n  // Bind Baz\r\n  container.bind(Baz);\r\n\r\n  // Resolve bar\r\n  Bar bar = container.get(Bar);\r\n  Bar bar2 = container.getAs(\"bar2\");\r\n  \r\n  // Test result\r\n  assert(bar.baz.name == bar2.baz.name);\r\n}\r\n</pre>\r\n\r\n###Factory methods\r\n\r\nThe Factory methods have maximum flexibility to generate any type of injected values\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n//application code\r\nclass Network{\r\n  String uri;\r\n  \r\n  Network(this.uri);\r\n}\r\n\r\nclass User {\r\n  String name;\r\n}\r\n\r\nclass Manager{\r\n  Network network;\r\n  User user;\r\n\r\n  Manager(this.user);\r\n}\r\n\r\nvoid main() {\r\n  // Create IoC container\r\n  Container container = new Container();\r\n\r\n  // Add host\r\n  container.bindAs(\"host\").toFactory((){\r\n    return \"http://127.0.0.1\";\r\n  });\r\n  \r\n  // Add Network\r\n  container.bind(Network).addConstructorRefArg(\"host\");\r\n  \r\n  // Add User\r\n  container.bind(User).setConstProperty(\"name\", \"Admin\");\r\n  \r\n  // Add Manager\r\n  container.bind(Manager).toFactory((){\r\n    Manager bar = new Manager(container.get(User));\r\n    bar.network = container.get(Network);\r\n    return bar;\r\n  });\r\n  \r\n  // Resolve Manager\r\n  Manager manager = container.get(Manager);\r\n\r\n  // Test result\r\n  assert(manager.network.uri == \"http://127.0.0.1\");\r\n  assert(manager.user.name == \"Admin\");\r\n}\r\n</pre>\r\n\r\n###Object scopes\r\n\r\nLost Dart supports two scopes: singleton and prototype. The first is used by default and does not need to be explicitly specified in binding.\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n//application code\r\nclass Baz{\r\n}\r\n\r\nvoid main() {\r\n  // Create IoC container\r\n  Container container = new Container();\r\n  \r\n  // Add Baz\r\n  container.bind(Baz).asPrototype();\r\n  \r\n  // Resolve baz - \"prototype\" scope.\r\n  Baz baz = container.get(Baz);\r\n  Baz baz1 = container.get(Baz);\r\n  // Test prototype result\r\n  assert(baz != baz1);\r\n}\r\n</pre>\r\n\r\n###Batch binding\r\n\r\nTo add an array of types in a Container you can use the bindAll method.\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\nclass Baz{\r\n}\r\n\r\nclass Bar{\r\n}\r\n\r\nclass Foo{\r\n}\r\n\r\nvoid main() {\r\n  Container container = new Container();\r\n\r\n  container.bindAll([\r\n    Baz,\r\n    Bar,\r\n    Foo\r\n  ]);\r\n\r\n  Foo foo = container.get(Foo);\r\n\r\n  assert(foo != null);\r\n}\r\n</pre>\r\n\r\n###Multi injection\r\n\r\nLost Dart allows you to inject multiple objects bound to a particular type or interface. There are Weapon interface, and two implementations, Sword and Dagger.\r\nThe constructor of Samurai class takes an array of Weapon. The toFactory method of Binder return the list of Weapons to be used in Samurai constructor.\r\n\r\n<pre class=\"syntax brush-javascript\">\r\nimport 'package:lost_dart/lost_dart.dart';\r\n\r\n/**\r\n * Asbtract class Weapon\r\n */\r\nabstract class Weapon\r\n{\r\n  /**\r\n   * Hit the [target].\r\n   */\r\n  String Hit(String target);\r\n}\r\n\r\n/**\r\n * Sword Weapon\r\n */\r\nclass Sword implements Weapon \r\n{\r\n  /**\r\n   * Hit the [target].\r\n   */\r\n  String Hit(String target) \r\n  {\r\n    return \"Slice \" + target + \" in half\";\r\n  }\r\n}\r\n\r\n/**\r\n * Dagger Weapon\r\n */\r\nclass Dagger implements Weapon \r\n{\r\n  /**\r\n   * Hit the [target].\r\n   */\r\n  String Hit(String target) \r\n  {\r\n    return \"Stab \" + target + \" to death\";\r\n  }\r\n}\r\n\r\n/**\r\n * Samurai fully equipped.\r\n */\r\nclass Samurai \r\n{\r\n  List<Weapon> allWeapons;\r\n\r\n  Samurai(List<Weapon> this.allWeapons); \r\n\r\n  /**\r\n   * Just attack the [target].\r\n   */\r\n  void Attack(String target) \r\n  {\r\n    for (Weapon weapon in this.allWeapons) {\r\n      print(weapon.Hit(target));\r\n    }\r\n  }\r\n}\r\n\r\nvoid main() {\r\n  Container container = new Container();\r\n  \r\n  // Bind Sword\r\n  container.bind(Sword);\r\n  // Bind Sword\r\n  container.bind(Dagger);\r\n  // Bind weapons as list\r\n  container.bindAs(\"weapons\").toFactory(() {\r\n    return [container.get(Sword), container.get(Dagger)];\r\n  });\r\n  \r\n  \r\n  // Bind Samurai with list of weapons\r\n  container.bind(Samurai).addConstructorRefArg(\"weapons\");\r\n  \r\n  \r\n  // Get samurai \r\n  Samurai samurai = container.get(Samurai);\r\n  // Atack\r\n  samurai.Attack(\"your enemy\");\r\n}\r\n</pre>","google":"dart language,dependency injection,inversion of control","note":"Don't delete this file! It's used internally to help with page regeneration."}